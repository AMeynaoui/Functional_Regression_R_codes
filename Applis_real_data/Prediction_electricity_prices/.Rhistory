FP.lasso.app.cv = mean(Ytest==0 & lasso.cv.app.pred==1)
FN.lasso.app.cv = mean(Ytest==1 & lasso.cv.app.pred==0)
# Lasso + BIC
lasso.BIC.app.proba = predict(lasso.mod.app,newx=Xtest,s=lambda.BIC.app,type='response')
boxplot(lasso.BIC.app.proba~Ytest,main="Estimation de p_i avec GLM Lasso + BIC")
lasso.BIC.app.pred = lasso.BIC.app.proba>=0.5
err.lasso.app.BIC = mean((Ytest!=lasso.BIC.app.pred))
FP.lasso.app.BIC = mean(Ytest==0 & lasso.BIC.app.pred==1)
FN.lasso.app.BIC = mean(Ytest==1 & lasso.BIC.app.pred==0)
?plot.cv.glmnet
Ridge.pred = Ridge.pred.proba>=0.5
err.Ridge = mean((Ytest!=Ridge.pred))
FP.Ridge = mean(Ytest==0 & Ridge.pred==1)
FN.Ridge = mean(Ytest==1 & Ridge.pred==0)
print(paste("Erreur de classification du Ridge",err.Ridge))
Ridge.pred = Ridge.pred.proba>=0.5
err.Ridge = mean((Ytest!=Ridge.pred))
FP.Ridge = mean(Ytest==0 & Ridge.pred==1)
FN.Ridge = mean(Ytest==1 & Ridge.pred==0)
print(paste("Erreur de classification du Ridge",round(err.Ridge,2))
?round
Ridge.pred = Ridge.pred.proba>=0.5
err.Ridge = mean((Ytest!=Ridge.pred))
FP.Ridge = mean(Ytest==0 & Ridge.pred==1)
FN.Ridge = mean(Ytest==1 & Ridge.pred==0)
print(paste("Erreur de classification du Ridge",round(err.Ridge,2)))
Ridge.pred = Ridge.pred.proba>=0.5
err.Ridge = mean((Ytest!=Ridge.pred))
FP.Ridge = mean(Ytest==0 & Ridge.pred==1)
FN.Ridge = mean(Ytest==1 & Ridge.pred==0)
print(paste("Erreur de classification du Ridge",round(100*err.Ridge,2),"%"))
Ridge.pred = Ridge.pred.proba>=0.5
err.Ridge = mean((Ytest!=Ridge.pred))
FP.Ridge = mean(Ytest==0 & Ridge.pred==1)
FN.Ridge = mean(Ytest==1 & Ridge.pred==0)
print(paste("Erreur de classification du Ridge",round(100*err.Ridge,2),"%"))
print(paste("Taux de faux positifs",round(100*FP.Ridge,2),"%"))
print(paste("Taux de faux négatifs",round(100*FN.Ridge,2),"%"))
2+2*(4/5)
2+2*(5/4)
2.5*(10/12)
2.75*(5/4)
1+2,08+3,44
1+2.5*(10/12)+2.75*(5/4)
3+5.75*(10/12)+2.75*(5/4)
3.5+4.75*(10/12)+1*(5/4)
2+7*10/12
(2-4)/(3*4-2)
(2-6)/(3*6-2)
18*3
plot(sqrt)
x = seq(0.001,10,length=1000)
plot(x,sin(1/x),type='l')
plot(x,1-exp(-x),type='l')
abline(0,1,col='red')
x = seq(5,10,length=100)
plot(x,1-5/x,type='l')
x = seq(5,100,length=100)
plot(x,1-5/x,type='l')
p = seq(1/2,1/3,1/6)
p = c(1/2,1/3,1/6)
sum(p)
rmultinom(1,10,p)
rmultinom(1,100,p)
sin(0)
sin(pi/10)
sin(2*pi/10)
cos(0)
X
X = c(2.03, 2.11, 1.84, 1.89, 1.92, 2.12, 1.91, 1.99, 2.11, 2 )
mean(X)-sd(X)/sqrt(10)*1.96
mean(X)+sd(X)/sqrt(10)*1.96
sd(X)
qnorm(0.95)
qnorm(0.99)
qnorm(0.99)+1200/0.1
Delta<-qnorm(0.99)+1200/0.1
(-qnorm(0.99)+sqrt(Delta))/(2*sqrt(0.9/0.1))
(-qnorm(0.99)-sqrt(Delta))/(2*sqrt(0.9/0.1))
plot(qnorm)
(-qnorm(0.99)-sqrt(Delta))/(2*sqrt(0.9/0.1))->xp
xp^2
13/12000
1*10^(-4)
hatp = 13/12000
hatp-sqrt(1/(4*12000*0.05))
hatp+sqrt(1/(4*12000*0.05))
hatp-sqrt(hatp*(1-hatp)/n)*qnorm(0.975)
hatp+sqrt(hatp*(1-hatp)/n)*qnorm(0.975)
4.3-sqrt(6.76/100)*1.96
4.3+sqrt(6.76/100)*1.96
4.3-sqrt(6.76/100)*1.64
4.3+sqrt(6.76/100)*1.64
10.4+122+99+31.9
263.3+59.8
factorial(6)
720-36
684*6^(-2/3)/9
function(k){(1/k^2)*factorial(k)^(4/k-2)*(factorial(2*k)-factorial(k)^2)
}
function(k){(1/k^2)*factorial(k)^(4/k-2)*(factorial(2*k)-factorial(k)^2)}->coef
plot(1:10,coef(1:10))
function(k){(1/k^2)*factorial(k)^(4/k-2)*(factorial(2*k)-factorial(k)^2)}->CC
plot(1:10,CC(1:10))
CC<-function(k){(1/k^2)*factorial(k)^(4/k-2)*(factorial(2*k)-factorial(k)^2)}
plot(1:10,CC(1:10))
CC(1)
CC(2)
CC(10)
21.94+29.25+29.25+18+45
29.25+21.94+12+20.25+40.5+5+20
20.25+27+20
114+22.4
45+101.4
45+101.4+21.94+29.25+15.6+5.62+20
25.35/19.5
13.65/10.5
45+39
45+39+15.6/2
2-2*log(2)
log(2)
2**3
1.2*3.3+1
1.2*8+1
1.4+5+1.75
1.2*8.15+1
1.2*5+1
0.9+1.5+0.25
1.2*2.65+1
1.2*5.65+1
1.2*7.75+1
1.2*3.45+1
1.2*5.15+1
1.2*5.75+1
1.2*7.25+1
1.2*12.2+1
1.2*7+1
1.2*2.75+1
1.2*4.2+1
1.2*5.45+1
1.2*4.65+1
1.2*10.1+1
1.2*4.5+1
1.2*5.15+1
1.2*3.45+1
1.2*4.65+1
1.2*9.85+1
1.2*6.4+1
1.2*2.35+1
1.2*6.35+1
1.2*6.2+1
2.1+0.75+1.75+2.35
2.1+0.75+1.75
4.6*1.2+1
8*1.2+1
7.5*1.2+1
library("cluster", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
example(cluster)
example("kmeans")
plot(x,col=cl$cluster)
plot(x,col=cl$cluster,pch=16)
plot(x,col=cl$cluster,pch=16,cex=2)
plot(x,col=cl$cluster,pch=16,cex=1.2)
plot(x,pch=16)
plot(x,col=cl$cluster,pch=16,cex=1)
setwd("~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic")
source("PCA.R") # loading the functions for fPCA
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
install.packages("rstudioapi")
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
plot(simuX(1,100))
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/functions_simusXY.R')
plot(simuX(1,100))
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/functions_simusXY.R')
plot(simuX(1,100))
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/functions_simusXY.R')
plot(simuX(1,100))
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/functions_simusXY.R')
plot(simuX(1,100))
plot(as.vector(simuX(1,100)))
plot(as.vector(simuX(1,100)))
plot(as.vector(simuX(1,100)))
plot(as.vector(simuX(1,100)))
plot(as.vector(simuX(1,100,set='IK17')))
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
Xi = simuX(n,kreal=8,lambda = (pi*(0.5:(kreal-0.5)))^(-2))
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
View(simuX)
View(simuX)
View(simuX)
View(simuX)
View(simuX)
View(simuX)
Xi = simuX(n,kreal=8,lambda = (pi*(0.5:7.5))^(-2))
?Vectorize
Vectorize(cos)
?crossprod
?tcrossprod
Yi = simuY(X,operator,noise="Brownian",q=q,fac=20)
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
Yi = simuY(Xi,operator,noise="Brownian",q=q,fac=20)
mats = matrix(rep(seq(0,1,length.out=p),q),p,q)
p=2
q=3
mats = matrix(rep(seq(0,1,length.out=p),q),p,q)
mats
?matrix
matt = matrix(rep(t),p,p,q,byrow = T )
t = 1:q
matt = matrix(rep(t),p,p,q,byrow = T )
matt = matrix(rep(t,p),p,q,byrow = T )
matt
X %*% kernel(mats,matt)/p
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/Simus_Crambes&Mas2013.R')
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
plot(Y[1,],type='')
plot(Y[1,],type='l')
plot(Yi[1,],type='l')
plot(Yi[2,],type='l')
plot(Yi[3,],type='l')
Xi = simuX(n,lambda = (1:k1)^(-alpha/2),set="IK18",loi="unif")
alpha = 1.2
alpha = 1.2
k1 = 50
Xiii = simuX(n,lambda = (1:k1)^(-alpha/2),set="IK18",loi="unif")
plot(Xiii[i,],type='')
plot(Xiii[i,],type='l')
plot(Xiii[1,],type='l')
plot(Xiii[2,],type='l')
plot(Xiii[3,],type='l')
crossprod(1:3,seq(0,1,length=50))
tcrossprod(1:3,seq(0,1,length=50))
dim(tcrossprod(1:3,seq(0,1,length=50)))
Phip = sqrt(2)*cos(2*pi*tcrossprod(1:k1,gridX))
gridX = seq(0,1,length.out=p)
Phip = sqrt(2)*cos(2*pi*tcrossprod(1:k1,gridX))
beta = 3
gam = 2.5
B = 4*tcrossprod((-1)^(1:k1)*(1:k1)^gam,(-1)^(1:k1)*(1:k1)^beta)
B
B = 4*tcrossprod((-1)^(1:k1)*(1:k1)^(-gam),(-1)^(1:k1)*(1:k1)^(-beta))
head(B)
?crossprod
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
source("functions_estim.R")
View(Dim.Selec)
kappa = 0.6
hatm1 <- Dim.Selec(kappa,50,Xi,Yi)
sigma2i = 1/(2*(20)^2)
sigma2ii = 1/8
sigma2iii = sum((1:k1)^(-delta))
delta = 1.1
sigma2iii = sum((1:k1)^(-delta))
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/main_simus.R')
source("../../functions_estim.R")
setwd("~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/Applis_real_data/Prediction_electricity_prices")
source("../../PCA.R")
source("../../functions_estim.R")
data.all <- read.csv(file="Data_Jan_2006_Sep_2008.csv", sep=";", header=TRUE)
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/Applis_real_data/Prediction_electricity_prices/mainElecWindLeibl.R')
source("../../PCA.R")
source("../../functions_estim.R")
#################################################################################################################
# Extract of an initial file written by Dominik Liebl (importation of data)                                     #
#################################################################################################################
data.all <- read.csv(file="Data_Jan_2006_Sep_2008.csv", sep=";", header=TRUE)
## data-selector:=======================
peakload    <- rep(c(rep(FALSE,8),rep(TRUE,12),rep(FALSE,4)), (dim(data.all)[1]/24))
data.peakh  <- data.all[peakload,]
data.offph  <- data.all
## data.selector can be either data.selector="all", "peakh", or "offph"
data.list       <- switch("all",
all   = list("data"=data.all,  "T"=dim(data.all)[1]/24,   "N"=24),
peakh = list("data"=data.peakh,"T"=dim(data.peakh)[1]/12, "N"=12),
offph = list("data"=data.offph,"T"=dim(data.offph)[1]/24, "N"=24))
##=======================================
## day-index variable
first.day   <- min(data.list$data$DayIndex)
last.day    <- max(data.list$data$DayIndex)
days        <- c(first.day:last.day)
## Selection of non-workdays:
source("holidays_and_brueckentage.R")
Sys.getlocale("LC_TIME")
Sys.setlocale("LC_TIME", "C")
Da.vec <- matrix(data.all$Date, nrow=24)[1,]
Da.vec <- as.Date(Da.vec, "%d.%m.%Y")
feier  <- as.Date(feiertage, "%d.%m.%Y")
DUMMYSU    <- as.numeric(weekdays(Da.vec)=="Sunday")
DUMMYSA    <- as.numeric(weekdays(Da.vec)=="Saturday")
DUMMYMO    <- as.numeric(weekdays(Da.vec)=="Monday")
DUMMYFEIER    <- as.numeric(!is.na(match(Da.vec,feier)))
DUMMYPSEUDOMO <- as.numeric(!is.na(match(Da.vec,feier+1)))
non.workdays  <- c(1:length((Da.vec)))[c(as.logical(DUMMYSU)|as.logical(DUMMYSA)|as.logical(DUMMYFEIER))]
## Taking non-workdays from the sample
tmp  <- match(non.workdays, days)
tmp  <- tmp[!is.na(tmp)]
days <- days[-tmp]
## Number of days 'T' and hours 'N':
T <- length(days)
N <- data.list$N
## Container for data
RL.Prices <- matrix(NA, N, T)
RL.Wind   <- matrix(NA, N, T)
j <- 1
for(t in (days)){
RL.Prices[,j]              <- data.list$data$Price[data.list$data$DayIndex==t]
##
RL.Wind[,j]                <- data.list$data$Windinfeed[data.list$data$DayIndex==t]
##
j <- j+1
}
Xbar = rowMeans(RL.Wind)
X = t(RL.Wind-Xbar)
t = 1:24
n = nrow(X)
p = ncol(X)
par(mfrow=c(1,2))
plot(range(t),range(RL.Wind),type='n',xlab='time(hour)',ylab='wind infeed (kWh)',main="Non-centered data")
for (i in 1:n){
points(t,RL.Wind[,i],type='l',lty=2,col='gray')
}
points(t,Xbar,type='l',col=2,lty=2,lwd=2)
plot(range(t),range(X),type='n',xlab='time(hour)',ylab='',main='Centered data')
for (i in 1:n){
points(t,X[i,],type='l',col=i)
}
abline(h=0,col='red',lwd=2)
par(mfrow=c(1,2))
plot(range(t),range(RL.Wind),type='n',xlab='time(hour)',ylab='wind infeed (kWh)',main="Original data")
for (i in 1:n){
points(t,RL.Wind[,i],type='l',lty=2,col='gray')
}
points(t,Xbar,type='l',col=2,lty=2,lwd=2)
plot(range(t),range(X),type='n',xlab='time(hour)',ylab='',main='Centered data')
for (i in 1:n){
points(t,X[i,],type='l',col='lightblue')
}
abline(h=0,col='red',lwd=2)
maxs = apply(RL.Prices,2,max)
dim(maxs)
length(max)
dim(RL.Prices)
length(maxs)
outliers(max)
?quantiles
?quantile
quartiles = quantiles(maxs,c(0.25,0.75))
quartiles = quantile(maxs,c(0.25,0.75))
indext = which(maxs>Q3+1.5*(Q3-Q1),arr.ind=T)[,1]
Q1 = quantile(maxs,0.25)
Q3 = quantile(maxs,0.75)
indext = which(maxs>Q3+1.5*(Q3-Q1),arr.ind=T)[,1]
indext = which(maxs>Q3+1.5*(Q3-Q1),index.return=T)$ix
indext = which(maxs>Q3+1.5*(Q3-Q1))
indext = which(maxs<=Q3+1.5*(Q3-Q1))
Xbar = rowMeans(RL.Wind[,indext])
maxs = apply(RL.Prices,2,max)
Q1 = quantile(maxs,0.25)
Q3 = quantile(maxs,0.75)
indext = which(maxs<=Q3+1.5*(Q3-Q1))
Xbar = rowMeans(RL.Wind[,indext])
X = t(RL.Wind[,indext]-Xbar)
Ybar = rowMeans(RL.Prices[,indext])
Y = t(RL.Prices[,indext]-Ybar)
t = 1:24
n = nrow(X)
p = ncol(X)
par(mfrow=c(1,2))
plot(range(t),range(RL.Wind),type='n',xlab='time(hour)',ylab='wind infeed (kWh)',main="Original data")
for (i in 1:n){
points(t,RL.Wind[,i],type='l',lty=2,col='gray')
}
points(t,Xbar,type='l',col=2,lty=2,lwd=2)
plot(range(t),range(X),type='n',xlab='time(hour)',ylab='',main='Centered data')
for (i in 1:n){
points(t,X[i,],type='l',col='lightblue')
}
abline(h=0,col='red',lwd=2)
par(mfrow=c(1,2))
plot(range(t),range(RL.Wind),type='n',xlab='time(hour)',ylab='wind infeed (kWh)',main="Original data")
for (i in indext){
points(t,RL.Wind[,i],type='l',lty=2,col='gray')
}
points(t,Xbar,type='l',col=2,lty=2,lwd=2)
plot(range(t),range(X),type='n',xlab='time(hour)',ylab='',main='Centered data')
for (i in indext){
points(t,X[i,],type='l',col='lightblue')
}
abline(h=0,col='red',lwd=2)
par(mfrow=c(1,2))
plot(range(t),range(RL.Wind),type='n',xlab='time(hour)',ylab='wind infeed (kWh)',main="Original data")
for (i in indext){
points(t,RL.Wind[,i],type='l',lty=2,col='gray')
}
points(t,Xbar,type='l',col=2,lty=2,lwd=2)
plot(range(t),range(X),type='n',xlab='time(hour)',ylab='',main='Centered data')
for (i in 1:n){
points(t,X[i,],type='l',col='lightblue')
}
abline(h=0,col='red',lwd=2)
par(mfrow=c(1,2))
plot(range(t),range(RL.Prices),type='n',xlab='time(hour)',ylab='price (€/kWh)',main="Non-centered data")
for (i in indext){
points(t,RL.Prices[,i],type='l',lty=2,col='gray')
}
points(t,Ybar,type='l',col=2,lty=2,lwd=2)
plot(range(t),range(Y),type='n',xlab='time(hour)',ylab='',main='Centered data')
for (i in 1:n){
points(t,Y[i,],type='l',col=i)
}
abline(h=0,col='red',lwd=2)
par(mfrow=c(1,2))
plot(range(t),range(RL.Prices[,indext]),type='n',xlab='time(hour)',ylab='price (€/kWh)',main="Original data")
for (i in indext){
points(t,RL.Prices[,i],type='l',lty=2,col='gray')
}
points(t,Ybar,type='l',col=2,lty=2,lwd=2)
plot(range(t),range(Y),type='n',xlab='time(hour)',ylab='',main='Centered data')
for (i in 1:n){
points(t,Y[i,],type='l',col=i)
}
abline(h=0,col='red',lwd=2)
par(mfrow=c(1,2))
plot(range(t),range(RL.Prices[,indext]),type='n',xlab='time(hour)',ylab='price (€/kWh)',main="Original data")
for (i in indext){
points(t,RL.Prices[,i],type='l',lty=2,col='gray')
}
points(t,Ybar,type='l',col=2,lty=2,lwd=2)
plot(range(t),range(Y),type='n',xlab='time(hour)',ylab='',main='Centered data')
for (i in 1:n){
points(t,Y[i,],type='l',col=i-"lightblue")
}
abline(h=0,col='red',lwd=2)
par(mfrow=c(1,2))
plot(range(t),range(RL.Prices[,indext]),type='n',xlab='time(hour)',ylab='price (€/kWh)',main="Original data")
for (i in indext){
points(t,RL.Prices[,i],type='l',lty=2,col='gray')
}
points(t,Ybar,type='l',col=2,lty=2,lwd=2)
plot(range(t),range(Y),type='n',xlab='time(hour)',ylab='',main='Centered data')
for (i in 1:n){
points(t,Y[i,],type='l',col="lightblue")
}
abline(h=0,col='red',lwd=2)
Ybar = rowMeans(log(RL.Prices[,indext]+1))
Y = t(log(RL.Prices[,indext]+1)-Ybar)
par(mfrow=c(1,2))
plot(range(t),range(RL.Prices[,indext]),type='n',xlab='time(hour)',ylab='price (€/kWh)',main="Original data")
for (i in indext){
points(t,RL.Prices[,i],type='l',lty=2,col='gray')
}
points(t,Ybar,type='l',col=2,lty=2,lwd=2)
plot(range(t),range(Y),type='n',xlab='time(hour)',ylab='',main='Centered data')
for (i in 1:n){
points(t,Y[i,],type='l',col="lightblue")
}
abline(h=0,col='red',lwd=2)
par(mfrow=c(1,2))
plot(range(t),range(RL.Prices[,indext]),type='n',xlab='time(hour)',ylab='price (€/kWh)',main="Original data")
for (i in indext){
points(t,RL.Prices[,i],type='l',lty=2,col='gray')
}
points(t,rowMeans(RL.Prices[,indext]),type='l',col=2,lty=2,lwd=2)
plot(range(t),range(Y),type='n',xlab='time(hour)',ylab='',main='Centered data')
for (i in 1:n){
points(t,Y[i,],type='l',col="lightblue")
}
abline(h=0,col='red',lwd=2)
kappa = 0.6
Nn = 15
res.CV <- CVpred(Xnewbar,Ynewbar,kappa,Nn)
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/functions_estim.R')
res.CV <- CVpred(Xnewbar,Ynewbar,kappa,Nn)
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/functions_estim.R')
res.CV <- CVpred(Xnewbar,Ynewbar,kappa,Nn)
n
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/functions_estim.R')
res.CV <- CVpred(Xnewbar,Ynewbar,kappa,Nn)
res.CV <- CVpred(X,Y,kappa,Nn)
n = nrow(X)
p = ncol(X)
mhat = rep(NA,n)
risk = rep(NA,n)
Yhat = matrix(NA,n,p)
ntest = 1
i=1
napp = n-ntest
Xapp = X[-i,]
Xapp = X[-i,]
Yapp = Y[-i,]
Xtest = X[i,]
Ytest = Y[i,]
Selecapp <- Dim.Selec.sigmahat(kappa,Nn,Xapp,Yapp)
mhat[i]=Selecapp$hatm1
names(Selecapp)
Selecapp
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/functions_estim.R')
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/functions_estim.R')
res.CV <- CVpred(X,Y,kappa,Nn)
Selecapp <- Dim.Selec.sigmahat(kappa,Nn,Xapp,Yapp)
mhat[i]=Selecapp$Dim.Selec
source('~/Dropbox/RegressionReponseFonctionnelle/Simus/SimusPublic/functions_estim.R')
res.CV <- CVpred(X,Y,kappa,Nn)
